# 代码大全读书笔记

##第一章 软件构建
    
    将通常我们认为的coding，programming看成construct，对于写代码，更重要的是明确软件/系统/web等等的构建过程
    
    软件构建过程：
    
    1.定义问题
    
    2.需求分析
    
    3.规划构建
    
    4.软件架构/高层设计
    
    5.详细设计
    
    6.编码与调试
    
    7.单元测试
    
    8.集成测试
    
    9.集成
    
    10.系统测试
    
    11.保障维护
    
    我个人的看法是1,2是确定需求的过程，确定下来我们需要做些啥，在问题明确的基础上进行3,4,5即架构设计部分，
    这部分最为消耗脑细胞，既要具有一些前瞻性，也不能过于将系统变得复杂，而6就是我们正常而言的coding阶段，
    7~10是测试阶段，为了确保代码不要太惨，在接受大众摧残前要保证不会有明显的bug，最后的保障维护就是在系统
    上线后能对其发生的问题进行维护
    
    构建活动是软件开发中的核心活动，开发的主要时间是用于构建活动，可以提高开发效率，源代码是对构建活动的唯一精确描述，是构建活动的产物

## 第二章 隐喻对软件开发的指导

    隐喻与算法
    
    隐喻：将软件开发的过程与传统行业或者活动进行对比，通过传统活动的一些好的方法来指导代码构建，常见的有将软件开发比作写作，培育，建造。
    
    算法：可预测的，确定性的，不易变化的

## 第三章 前期准备的重要性

    1.前期准备是十分重要的，一般而言，构建活动占整个过程的65%
    
    2.测试是质量保证的后续环节，真正对系统的质量保证是前期准备中的高质量设计
    
    3.实现一个系统前，一定要理解这个系统是做什么的，它该如何做到这些
    
    4.程序员是食物链的底层，架构师吃掉需求，设计师吃到架构，程序员消化设计
    
    5.3-1有一张表，各阶段解决问题的平均时间
    
    6.迭代技术往往能够减少“前期准备”不足，但不能完全解决
    
    7.序列式开发法和迭代式开发法
    
    需求稳定；设计直截了当，而且理解透彻；开发团队对于这一应用领域非常熟悉；项目的风险很小；"长期可预测性”很重要；后期改变需求，设计，编码的代价比较大 适合序列式开发法
    
    需求并没有被理解透彻，不稳定；设计很复杂，或者有挑战性，或者两者兼具；开发团队对于这一应用领域不熟悉；项目包含许多风险；“长期可预测性”不重要；后期改变需求，设计和编码的代价比较小 适合迭代式开发
    
    8.问题定义只定义问题是什么，问题定义应该用客户的语言来书写，而且应该从客户的角度来描述问题；未能定义问题可能会导致用大量的时间去解决错误的问题。同时你并没有解决问题。
    
    9.明确的需求很重要，明确的需求很重要，明确的需求很重要，你懂的，PM最好理解这点
    
    10.稳定的需求是开发的圣杯
    
    11.平均水平，需求会有25%的变化
    
    12.计划严格依照需求行事，实际上就是计划不对客户的要求做出回应
    
    13.构建期间处理需求变更
    
    1）利用书中的需求核对表来评估需求的质量 p42
    
    2）确保每一个人都知道需求变更的代价
    
    3）建立一套变更控制程序
    
    4）使用能适应变更的开发方法
    
    5）放弃这个项目
    
    6）注意项目的商业案例
    
    14.离开了良好的软件架构，你可能瞄准了正确的问题，却用了错误的方法，依然不会成功。
    
    15.架构需要注意的典型组成部分：
    
    1）程序组织
    
    2）主要的类；详细定义主要的类的功能
    
    3）数据设计；所用的数据库，数据表的设计
    
    4）业务规则；如果架构依赖于特定的规则，那么就应该详细描述这些规则
    
    5）用户页面设计：用户界面常常在需求阶段进行详细说明
    
    6）资源管理：架构应该描述一份管理稀缺资源的计划（数据库连接，线程，句柄等）
    
    7）安全性：架构应该描述实现设计层和代码层面的安全性的方法
    
    8）性能：性能目标可以包括资源的使用，这时，性能目标也应该详细定义资源之间的优先顺序
    
    9）可伸缩性：可伸缩性是指系统增长以满足未来需求的能力。
    
    10）互用性：与其他软件，硬件交互
    
    11）国际化/本地化：语言，编码等
    
    12）输入输出流一定要注意
    
    13）错误处理：是计算机科学中最棘手的问题之一
    
    14）容错性
    
    15）满足各类功能的架构可行性（我能否肝出来）
    
    16）过渡工程：系统在检测到错误后继续运行的能力
    
    17）对于上述系统，我们是造好，还是外包买好
    
    具体check checklist表
    
    14.一个运行良好的架构花费在问题定义，需求分析，软件架构上的时间，依据项目的需要而变化，一般在10%~30%左右


## 第四章 关键的构建决策

    1.选择适合的语言：我个人熟悉的语言C，C++，Java，PHP，略有了解的语言python，JavaScript，SQL，VB，C#，MATLAB，HTML，希望学习的语言Ruby，lua，Object C，scala，Haskell等，感觉学不完啊
    
    2.编程约定：树立自己的编码风格
    
    3.技术浪潮中自己的位置：技术变革中找准方向
    
    4.深入一种语言去编程：C++各类书籍，TIPI撸起
    
    5.选择主要的构建实践方法：p69，70两张很nice的checklist

## 第五章 软件构建中的设计

### 设计中的挑战

    软件设计意味着去构思，创造或发明一套方案方案，把一份计算机软件的规格说明书要求转变为实际运行的软件
    
    1.设计是一个“险恶”的问题——简单的讲这里的险恶多指挥不停地改变，你必须先解决一遍后再能更加明确地定义问题，从来迭代式地逼近真正要解决的问题，做出真正可以解决问题的设计（这是我个人的理解）
    
    2.软件设计的结果应该是1.组织良好 2.干净利落的，然而形成设计的过程是了无章法的。（设计的过程不像是解题，可以依据一定的公理方法来推出最后的结果，所以过程是充满错误的，而设计阶段发现错误并改正远比到了编码阶段时要的代价小）
    
    3.设计就是确定取舍和调整顺序的过程。（在算法竞赛中，时间复杂度往往直观重要，而在实际生产中，也许数据的量非常小，这个时候代码的可读性以及编写效率等成了较重的权重，取舍很重要）
    
    4.设计受到诸多限制（设计的要点，创造可能发生的事情，阻止可能发生的事情，后面的例子中也会有，比如子系统之间的通信，不能毫无限制可言）
    
    5.设计是不确定的，一个启发式的过程，是自然而然形成的，它是再不断的设计评估，非正式讨论，写试验代码以及修改试验代码中演化和完善的。
    
### 关键的设计概念
    
    1.全书最重要的观点目前来看没有之一：软件的首要技术使命——管理复杂度
    
    2.软件随着不停地迭代，加入新的功能，需要解决更大的难题，其交互行为越来越复杂，这些转而又增加了软件解决方案本质性困难，当项目因技术性原因而导致失败时，往往是因为失控的复杂度。
    
    3.当没有人知道对一处代码的改动会对其他代码造成什么影响的时候，项目也快停止进站了。
    
    4.陷入复杂度沼泽的现象——自己顽固地使用一种明显毫无作用的方法（我的理解是谁都知道这方法很蠢，但我们依然没有办法，系统过于复杂，我们除了用这种方法别无方法）。
    
    5.软件架构层次上，可以将系统划分为子系统以降低问题的复杂度，子系统之间互相依赖越少，越容易专注在问题的一部分（低耦合）
    
    6.高代价，低效率的设计的三种根源：用复杂的方法解决简单的问题；用简单但错误的方法解决复杂的问题；用不恰当的复杂的方法解决复杂的问题
    
    7.管理复杂度的方法：1.把任何人在同一时间需要处理的本质复杂度的量减到最少；2.不要让偶然性的复杂度无谓地快速增长
    
    8.理想设计的特征：最小的复杂度；易于维护；松散耦合；可拓展性；可重用性；高扇入（大量的类使用某个基础类）；低扇出（一个类里少量使用其他的类）；可移植性；精简性（不要有大量冗余代码）；层次性；标准技术（尽量使用标准，常用的技术）
    
    9.设计的层次：软件系统——>分解为子系统或包——>分解为类——>分解成子程序（routines）——>子程序的内部设计
    
### 设计构造块：启发式方法

    1.找出现实世界的对象
    
    2.形成一致的抽象（基类，用简化的观念来考虑复杂的概念）
    
    3.封装实现细节（不让别人看到复杂的内部逻辑细节，你能看到的就是你能得到的）
    
    4.当继承能简化设计时就继承（继承很危险，第六章有讲）
    
    5.信息隐藏（黑盒子，而不是玻璃盒，类的接口应该尽量少地暴露其内部工作机制。类很像冰山，只有1/8暴露在表面）信息隐藏所保管的秘密主要有两大类（1.隐藏复杂度，其他人不用关注，2.变化源，变化发生时，变化只在内部进行，其他人看来不会有影响）这点非常非常重要，做设计时好好问自己，要隐藏些什么。
    
    6.设计时好好分析哪里会发生变化或者变化的频率高于其他地方，将其找出来并隔离
    
    7.高内聚低耦合（老生常谈）
    
    8.使用一些常用的设计模式来解决问题（设计模式就是经过考验的前人的设计总结，轮子，最重要的在于降低风险以及便于其他人理解）这一块要单独看些书
    
    9.设计启发的一个总结p108
    
### 设计实践

    主体还是分而治之以及自顶向上自底向上这些方法相结合，还是之前的话，设计时了无章法的，所以要试
    
## 第六章 可以工作的类

    类的基础——ADT抽象数据结构，使用ADT的好处：隐藏实现细节；改动不会影响到整个程序；让接口提供更多的信息；更容易提高性能；让程序的正确性更显而易见；程序更具自我说明性（更好读）；类相关于有继承和多态的ADT
    
    1.良好的类接口：好的抽象（便于别人理解类抽象的是什么）；良好的封装（尽可能限制类与成员的可访问性，不要公开暴露成员数据，多使用private，不要把私用的实现细节放入类接口中，不要对类的使用者做假设；避免使用友元类，让阅读代码比写方便，千万避免破坏封装性的行为）；
    
    2.包含和继承，7+-2规则
    
    1）通过包含来实现has a关系，万不得已时才使用private继承来实现有一个关系，警惕超过7个数据成员的类
    
    2）用public继承来实现是一个关系，使用继承一定要有详细的说明，不然就别用，对基类一定要做严格的check，确保只继承需要的部分，不要覆盖一个不可覆盖的成员函数，公共接口，数据，操作尽量放在继承树种较高处；类是抽象概念，别混成实例，同样基类如果只有一个派生类，别过早设计，继承树的高度不能太高，3层左右就很复杂了，尽量使用多态来替代case，数据尽量private，protected也不是很安全
    
    3.类里面的子程序越多越容易出错，所以7+-2，减少类调用的子程序数量，低扇出，对其他子程序的间接调用尽量减少，一般而言减少类之间的相互合作
    
    4.创建类的原因：对象建模；抽象概念；降低复杂度；隔离复杂度；隐藏实现细节；限制改变影响；隐藏全局数据；让参数传递更流畅；建立中心控制点；代码复用；便于重构
    
    5.避免的类：万能类；无关紧要的类；别用动词命名类；
    
    
## 第七章

    1.不良子程序的常见问题：
        1）子程序名很差（之前打算重构的促销活动部分的displayPromo_XX）
        2）没有文档
        3）布局代码风格不统一
        4）传入参数命名问题，命名为inputXXX的就不能被改变
        5）读写全局变量
        6）所做事情没有一个统一的目的，太过杂糅
        7）没有防错（实践中经常遇到）
        8）出现过多神秘数值（多用定义）
        9）出现无用参数（很多IDE可以帮检查）
        10）参数过多以及参数顺序混乱（haojing里很多遗留代码也有这种问题）
    
    2.创建子程序的原因
        1）降低复杂度（全书很多都是围绕这个观点）
        2）引入中间易懂抽象，方便阅读
        3）避免代码重复（最初的想法）
        4）隐藏顺序，指针操作（有些算法的操作顺序比较反人类，指针操作亦然）
        5）提高可移植性
        6）简化复杂的布尔判断（各种check）
        7）方便以后修改（不用改多处了，同3）
        
    
    3.子程序层面上设计的考虑在于需要较高的内聚性，但功能的内聚性是我们希望的
    
    4.取一个好的子程序名（英文太差了，词汇贫瘠啊）
        1）正确描述子程序要干的事情
        2）避免使用无意义，模糊，表述不清的词汇
        3）不要仅通过数字来形成不同的子程序名（之前重构促销活动犯了错）
        4）子程序名长度9~15为宜
        5）给函数名时要对返回值有所描述（以后注意，是object还是array）
        6）尽量使用语气强烈的动词加宾语的形式。 p172有很多动词对比词
        
    
    5.子程序长度（超过200行时就要小心点了）
    
    6.子程序参数的使用
        1）使用所有的参数
        2）有一定的顺序（输入在前，状态，出错变量在后等）
        3）对参数要有一定的说明
        4）尽量控制在7个以内
        5）一个有意思的问题，是传入整个object还是其中某几个参数，看需要的这几个参数的作用，从需要表达何种抽象来考虑问题，调用子程序前有set up代码，调用子程序后有take down方法都是不好的设计
        
    
    7.函数和过程的对比，有无返回值，某些过程式的函数可返回执行结果。检查所有可能的返回路径，这里经常有可能有各种奇葩错误，不要返回指向局部数据的引用或指针
    
    8.宏：首先能不用尽量不用，有太多可以替代它的东西，命名全大写，一定要注意用大括号大起来，常见的宏定义错误 #define MULT(a) a*a
    
    9.inline：内联函数，好处：提高效率，坏处：子程序会变长，违反封装原则）

## 第八章 防御式编程
    
### 防御式编程核心思想是承认程序都会有问题，子程序不因传入错误数据而被破坏！
        1）检查所有来源于外部的数据的值（尤其防止sql，html，xml代码注入）
        2）检查子程序所有输入参数的值
        3）针对非法参数，制定错误处理方法

### 断言——用于代码中做各种假定，通常在开发阶段使用
        用错误处理代码来处理预期发生的状况，用断言来处理绝不应该发生的状况
        避免把需要执行的代码放入断言中
        对于高健壮性的代码，先断言再处理错误

### 常用错误处理方法
        1）返回中间值（0，null，“”这种）
        2）换用下一个正确数据
        3）返回上次返回值
        4）换用最接近的正确数据
        5）打log
        6）制定并返回错误码
        7）局部处理掉
        8）exit

### 正确性与健壮性（正确性宁愿挂也不返回错误模糊的值，健壮性的有点小错没关系，程序能持续跑就可以）

### 异常的使用
        1）只有在真正例外的时候抛出异常
        2）不能用异常来推卸责任
        3）不要在构造析构函数中抛出异常
        4）不要使用空catch
        5）尽力去了解所使用库会抛出的异常
        6）考虑异常的集中报告机制以及异常的替换机制

### 隔离程序（我的理解是使用中间件来处理错误的数据，除了中间件，其他内部类可以假定数据是干净可信的）
        隔栏内程序应使用断言技术，因为传进来的数据要背隔栏清理好

### 尽早引入一些辅助调试的代码（有计划地移除他们）

### 产品代码中保留防御式代码
        1）保留检查重要错误的代码
        2）删掉一些检查细微错误的代码
        3）去掉可以导致程序硬性崩溃的代码（die）
        4）保留可以让程序稳妥地崩溃的代码（即使挂也不让用户看到白页的502,404）
        5）记录错误信息（haojing线上错误邮件机制）
        
### 关于安全性问题，还有很多扩展阅读空间       

## 第九章 伪代码编程过程
    1.95%的问题是我自己造成的，剩下5%才是编译器或者硬件等其他因素造成的
    2.理解每一行代码的作用，这点非常重要，不能为了完成任务而忽略了这一点
    3.构造类以及其子程序的时候问自己：
        1）这个类是要做什么
        2）这个类要隐藏哪些信息
        3）类所要表达的抽象概念
    4.构造类的过程
        1）创建类的总体设计
        2）创建类中的子程序
        3）复审并测试整个类
    5.在注释下面填写代码，确保注释可以看出简单的伪代码，以后写代码对于自己负责的子程序要多说明input，output（有时确实感觉到明明是自己之前写的，但却不是很记得逻辑了，有好的注释避免别人和自己花太多时间去理解代码）    
    

## 第十章 使用变量的一般事项
    1.一个数据类型以及一些数据结构的测试（熟悉1，听过但记不清具体含义0.5，不清楚0）p239，作者超有意思的杜撰了几个名词，然后只要得分超过30的就明显是撒谎的，因为根本没有那些东西，不过我自己测下来的感觉是有不少0.5，比如B-树（以及B+树，我只记得是多路查找树，数据库中进行索引的，然后叶子节点是按照顺序排列的，但具体的一些规则，以及插入删除中运用的一些技巧就不记得了）于是它推荐了几本介绍数据结构以及算法的书
    2.有时要注意隐式声明（防止写错变量名，然而编译器不报错，可以关掉，或者养成声明所有变量）
    3.变量初始化原则——不合理的初始化是编程错误的常见根源之一
        1）在声明变量的时候初始化（对于php而言，第一次使用这个变量时就是初始化变量）
        2）在靠近变量第一次使用的位置初始化 //以前写算法竞赛代码比较喜欢用全局变量以及用一个子程序init来初始化变量，现在想想都是不好的习惯，虽然对于比赛也可以认为是不坏的
        3）理想主义：在第一次使用变量的位置声明和定义该变量
        4）多用const，final（防止不必要的改变）
        5）特别注意i，j，k（php下感觉还好，大多用foreach，多层带迭代变量的循环比较少）
        6）在构造函数里初始化数据成员（之前我是打算这么做的，但非常蠢，在构造函数里打数据库也不好）
        7）编译器开出变量未初始化警告
        8）对于子程序而言，一定要其检查输入输出
        9）程序开始时初始化工作内存
    4.作用域——这里并非强调语言上用何种方式实现怎样的作用域范围，而强调了对于变量的作用域我们要谨慎地设计，总的说来，我们要尽量将变量“发挥作用”集中在一起（也佐证了为何要去用子程序），好的变量引用要尽量局部化。
        1）跨度——变量不同使用处之间的距离，平均跨度——求个平均值，跨度过长会导致阅读时更加麻烦（屏幕不够大也许就要翻页了）
        2）存活时间，如在1,5,6,9行用过某变量，则跨度为4,1,3，平均值为（4+1+3）/3，而存活时间是9-1=8），对于一段代码或者一个子程序，其所有变量的平均存活“越短越好”（这个其实不能这么说，但不要太长），但同时减少跨度和存活时间是个好主意，写代码时虽然不会特地去计算，但还是会有意识地去想着将变量集中起来
        3）一些原则：循环开始时再去初始化循环里使用的变量，而不是在子程序开始时（说实话我以前一直超喜欢这么干），这样便于看出哪些变量会在循环中使用；直到变量即将被使用再为其赋值；相关语句放一起——>相关语句提取出来写成子程序；开始时采用最严格的可见性，根据实际情况对扩展变量的作用域
    5.作用域大的“好处”是程序员写的时候方便，可以随意访问变量的便捷，忽视了可能带来的风险。书中的很多观点不适合用于自己写个脚本这种，因为书中的观点是建立在代码是多人合作完成的大项目，是需要不断维护的，所以对我们而言，你写代码时的速度和便利性不如别人阅读你代码的便利性重要，而变量集中化后更方便后人阅读代码。文章称之威提高智力上的可管理性。
    6.持续性，垃圾用好不能因为语言有垃圾回收机制就不手动去管理内存（haojing调用数据库的Node::clean，以及php手动使用unset）
    7.变量绑定时间
        1）绑定时间：编码时；编译时；加载时（从文件中读取之类）；对象实例化；即时；
        2）绑定时间越早灵活性越差，但相反它的复杂度越低，使用具名变量要好过神秘数值
    8.常见三种控制结构：顺序，选择，循环
    9.为变量指定单一用途；
        1）文中原话：通过使用一些巧妙的方法，可以给一个变量赋予多种职责，不要使用这种奇技淫巧（竞赛写题看过很多这种奇技淫巧，自己也模仿过不少，现在想想表面上代码更简洁了，但却不方便理解了，最常见的做背包时的滚动数组降维就是个典型，充分利用了顺序，当时跟XQ讲解时一直让他理解不能，最后还是举了明确的例子模拟一遍才明白）
        2）避免让变量有隐性含义：如pageCount为已打印纸张数量，当其为-1时表明错误发生。（写最短路时，最喜欢省一个数组，直接用一个G，如果两者没有连接的边，则置为一个很大的值，然后强撸就行了，似乎最后是用另外一个数据来表示有无边）
        3）确保使用了所有已声明的变量（IDE会帮做太nice）
    
### 我TM真是各种中枪    

## 第十一章 变量的力量（学好英语的重要性）
    1.首先说明，我写代码一直为起变量名苦恼，大量情况下会用google翻一下，词汇量实在太贫乏了，而我也非常认同好的变量名很有用，以及好的代码就像让别人读英语文章一样轻松（虽然对于我来说并不轻松，我需要网易词典的帮助）
    2.好的变量名即可以准确表达描述该变量概念的名字
    3.好的变量名往往表达的是what（什么），而不是how（如何）
    4.都市传说变量名长度在8~20比较好
    5.例如total，average，sum，max，min，record这些限定词扔到最后面
    6.常用的对仗词
        1）begin/end
        2）first/last
        3）locked/unlocked
        4）min/max
        5）next/previous
        6）old/new
        7）opened/closed
        8）visible/invisible
        9）source/target
        10）up/down
    7.没有明确意义，仅仅起迭代作用的循环变量常用i，j，k，如果需要使用它进行一些运算，起个更加明确的名字（php使用时array迭代时也不要光就key=>value)
    8.为状态变量取一个比flag更好的名字，比如isLocked这种
    9.大量的临时变量用temp做变量名，区分清楚，有些有实际含义的，对其进行更加准确的表述
    10.布尔变量命名
        1）常用done，error，found，succes，ok，尽量不要用not前缀，如notFound这种名字，自己或者别人会绕进去的
        2）命名规则（驼峰法，下划线等）与项目组保持一致即可
    11.应该避免的一些情况：
        1）使用令人误解的缩写（缩写本身是个单词）
        2）避免使用具有相似含义的名字
        3）避免使用具有不同含义却有相似名字的变量
        4）避免使用数字（之前经常犯的错误）
        5）不要拼错单词
        6）不要仅靠大小写区分变量名
        7）避免使用多种语言（比如我请个变量名叫shimakaze）
        8）同7）例子，不要用一些跟业务无关，然而却是我们自己很喜欢的某件东西命名

## 第十二章 基本数据类型
    1.数值理论
        1）避免使用神秘数值，有一种观点认为主程序中只能出现0和1（最近越发觉得记录东西非常非常重要，很多之前做的case“完全”不记得是怎么搞的，都需要回头翻代码，虽然大多时候会恍然大悟，但真心觉得代码中不要出现这种令人费解的神秘数值）
        2）预防除零（常见问题，然而屡屡中招）
        3）注意类型转换
        4）避免混合类型比较（虽然这方面php相当宽松）
    2.整数
        1）检查整数除法（结果往往不是你想象的那样）
        2）检查整数溢出（老胡之前中过一招，代码中结果是-1，存入数据库某个字段，结果那个字段是unsigned int，而且那个字段的真实意义是money的价格，你懂的，同样我们经常遇到的二分搜索，取中值尽量使用mid = min + (max-min)/ 2）
    3.浮点数
        1）等价判断设置个阈值
        2）总而言之，注意精度问题，多用double吧
    4.字符和字符串
        1）同样注意不要出现神秘字符串
        2）避免off-by-one问题
        3）了解语言和开发环境对unicode的支持
        4）各种各样的编码问题
        5）字符串指针和字符数组的差异，字符串操作，使用strcmp，strcpy等（C中），C++ string类要好用多了
        6）用null来初始化无结束符的字符串
    5.布尔变量
        1）用布尔变量对程序进行文档说明
        2）用布尔变量来简化复杂的判断
    6.枚举类型——可以提高程序的可读性，要警惕明确赋值带来的失误
    7.具名常量
        1）在数据声明中使用
        2）避免使用文字量
        3）用具有适合作用域的变量或类来模拟具名常量
        4）统一地使用具名变量
    8.数组
        1）确认下标有没有超（php多确认下isset，in_array不会不好）
        2）考虑用容器来取代数组（简单讲，别人写好的容器就别自己写数组去模拟了）
        3）检查数组的边界点
        4）数组是多维的，确认下标使用是否正确
        5）多层嵌套循环里，千万注意不要把i写成j，j写成i
    9.自定义类型原则
        1）取一个功能导向的名字
        2）避免使用预定义类型
        3）不要重定义一个预定义的类型
        4）定义替代类型以便于移植
        

## 第十三章 不常见的数据类型
    1.已经说了不常见了，为什么不常见，原因很简单，能不用尽量不用
    2.结构体（有类了，结构体可以看成是全体公用数据成员的类，我以前也很喜欢用结构体，很好用，但有类了）
    3.指针
        1）最最重要导致尽量少用的原因是，姿势水平太低的程序员用指针是超容易出错的
        2）当你要去用指针时，确定你理解它
        3）小tips：在分配指针的域中删除指针；使用指针前检查指针；先检查指针所引用的变量再使用它；用狗牌字段检测损毁的内存；用额外的指针变量提高代码可阅读性，比如不要p->next->next->data这种可以把中间值提出来，于是要简化指针表达式啊；删节点时注意顺序；垃圾数据及时清理；
        4）所以别用啊指针啊，不，别自己裸写，能用封装好的容器就用
    4.全局数据
        1）问题显而易见，因为它是全局的，所以太过自由了，所以根据之前的理论，他的跨度和存在时间都太大了，所以复杂度过高，导致我们对其难以管理
        2）个别用用还是可以的，别烂用，所以无论是确定其为全局数据还是起名都要慎重
    
## 第十四章 组织直线型代码
    1.顺序结构的代码怎么写，有些顺序结构的代码之间存在依赖关系，先有09后有天
    2.组织好顺序结构的代码，让依赖关系更明晰
        1）取子程序名的时候突出依赖关系
        2）利用子程序参数暗示依赖关系（调用了相同的参数）
        3）用注释对顺序进行直接说明
    3.阅读代码时，如果需要跳来跳去，那么这是个糟糕的代码
    4.把相关的代码放到一起，代码组织的好，按照依赖关系，各段代码不会出现交叉

## 第十五章 使用条件语句
    1.先写正常代码，再处理不常见的情况
    2.确保对于等量分支是正确的，防止off-by-one错误
    3.if后面跟随有意义的语句，不要为空
    4.多考虑else情况，测试else正确性，检查if，else有没有反
    5.判断复杂时将其提出来写成布尔函数
    6.最常见的情况放最前面
    7.case语句的用法
        1）排列有序，不要乱序，按字母顺序，按功能结构，按使用频率
        2）简化每种情况对应的操作
        3）不要为了使用case语句而刻意造没有实际意义的变量
        4）default只用于默认情况
        5）不要利用语言特性滥用case（不break）

## 第十六章 控制循环
    1.阻止循环发生错误的方法
        1）减少能影响循环的因素数量，简化简化再简化
        2）把循环内部看成是黑盒子，从这个角度讲，使用break的循环更容易出错
    2.写循环结构的原则
        1）只从一个地方进入循环
        2）把初始化的代码紧放在循环前面
        3）用while（true）表示无限循环
        4）适当情况下多使用for循环（控制代码部分集中在一起）
        5）while循环更适用时不要用for循环
        6）不管多短，都用{}括起来
        7）避免空循环（写快排时喜欢这么写for (;a[i] < x;i ++);这么写不如写while (a[i] < x) i ++;直观）
        8）循环只做一件事（有些从代码正确性上可以放一起，但其实他们不是在做一件事情）
        9）i++，j++这种控制循环的内务操作集中放到循环体开头或者结尾
    3.使用continue和break可以令循环更加灵活，但要小心有很多break，continue的循环体
    4.检查循环端点是否正确
    5.用有意义的变量名来替代i，j，k使得代码更易于阅读，以及避免下标串话
    6.循环下标的作用域限制在循环体内
    7.循环尽可能短，15~20lines为宜，嵌套三层以内，考虑将较长的部分功能化成子程序
    8.代码较长时，利用continue，break来使得逻辑更加清晰

## 第十七章 不常见的控制结构
    1.首先不常见就是少用
    2.增强阅读性的情况下，使用return，如利用return错误信息来做异常处理（防卫子句），适当减少每个子程序中的return数量
    3.递归使用注意点
        1）确认递归终止条件
        2）使用安全计数器来防止无穷递归（卡节点）
        3）把递归限制在一个子程序里，不要出现A->B->C->A这样的循环调用（大大增加管理理解难度，代码复杂度猛增）
        4）作者（不是我）怒斥了很多计算机科学教课书讲解递归时使用了愚蠢的计算阶乘，费布那切数列作为例子。原话如下：为我工作的程序员如果用递归去计算阶乘，我会炒了他。作者通过这个例子总结三点经验。计算机科学教程中给出的递归例子没有给世界带来任何好处；递归是强大的工具，功能之强大远超使用它们去计算阶乘和费布那切数列；所有的递归都能通过栈+循环来模拟实现，如何选择，试具体情况来定。
    4.goto语句使用原则
        1）不熟悉，没经验的别用，事实上99%的情况下你不会用到它，剩下几条是那1%情况下你要用它时的原则
        2）尽量在每个子程序内只使用一个goto标号
        3）尽量goto都统一向前跳不要向后跳了
        4）确认所有goto标号都被用到
        5）确认goto不会产生不被执行的代码
    5.诸如goto语句这些不常用的结构控制语句曾经都离奇地引起过轰动，如同现在的很多新技术或者新特性一样，然而并没有被广泛地接受

    
